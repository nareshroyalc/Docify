import json
from google.oauth2.service_account import Credentials
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
import os
from typing import List, Dict, Any
from datetime import datetime
from config import SECTION_EMOJIS, STYLE_CONFIG
from utils.formatting import (create_heading_style, create_styled_text, 
                              create_bullet_list, create_divider, create_code_block)
from utils.page_manager import get_safe_insertion_point, create_page_break

class DocsAgent:
    def __init__(self, service_account_file: str, scopes: List[str]):
        self.service_account_file = service_account_file
        self.scopes = scopes
        self.service, self.sa_email = self._init_service()
    
    def _init_service(self):
        if not os.path.exists(self.service_account_file):
            raise FileNotFoundError(f"{self.service_account_file} not found")
        
        creds = Credentials.from_service_account_file(self.service_account_file, scopes=self.scopes)
        service = build("docs", "v1", credentials=creds)
        
        with open(self.service_account_file, "r") as f:
            sa = json.load(f)
        return service, sa.get("client_email")
    
    def write_daily_entry(self, doc_id: str, doc_data: Dict) -> bool:
        """Write beautifully formatted documentation to Google Docs"""
        try:
            # Get document and find safe insertion point
            doc = self.service.documents().get(documentId=doc_id).execute()
            safe_index = get_safe_insertion_point(doc)
            
            print(f"üìç Inserting at index: {safe_index}")
            
            # Build professionally formatted requests
            requests = self._build_formatted_requests(safe_index, doc_data)
            
            print(f"üì¶ Generated {len(requests)} requests")
            
            # Execute batch update
            result = self.service.documents().batchUpdate(
                documentId=doc_id, 
                body={"requests": requests}
            ).execute()
            
            print("‚úÖ Documentation written successfully!")
            return True
            
        except HttpError as e:
            print(f"‚ùå Docs API Error: {e.resp['status']} - {e.content}")
            return False
        except Exception as e:
            print(f"‚ùå Error: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    def _build_formatted_requests(self, start_index: int, doc_data: Dict) -> List[Dict]:
        """Build document content as single insertion to avoid index errors"""
        data = doc_data["structured"]
        timestamp = doc_data["timestamp"]
        
        # Build complete content as single string
        content = f"""{"‚Äï" * 80}

{SECTION_EMOJIS['summary']} {data.get('title', 'Work Log Entry')}
üìÖ {timestamp}

{SECTION_EMOJIS['summary']} EXECUTIVE SUMMARY
{data.get('summary', 'No summary provided')}

üìù TASK DESCRIPTION
{data.get('task_description', 'No description')}

{SECTION_EMOJIS['achievements']} KEY ACHIEVEMENTS
"""
        
        # Add achievements
        for achievement in data.get('key_achievements', []):
            content += f"‚Ä¢ {achievement}\n"
        
        # Technical Implementation
        tech_impl = data.get('technical_implementation', {})
        content += f"""
{SECTION_EMOJIS['technical']} TECHNICAL IMPLEMENTATION
üîß Approach: {tech_impl.get('approach', 'N/A')}
‚öôÔ∏è Technologies: {', '.join(tech_impl.get('technologies', []))}
üèóÔ∏è Architecture: {tech_impl.get('architecture_decisions', 'N/A')}

{SECTION_EMOJIS['challenges']} CHALLENGES & SOLUTIONS
"""
        
        # Add challenges
        challenges = data.get('challenges_faced', [])
        if challenges:
            for challenge in challenges:
                if isinstance(challenge, dict):
                    content += f"‚ö†Ô∏è Challenge: {challenge.get('challenge', '')}\n"
                    content += f"‚úì Solution: {challenge.get('solution', '')}\n"
                    content += f"üí° Learning: {challenge.get('learning', '')}\n\n"
                else:
                    content += f"‚Ä¢ {challenge}\n"
        else:
            content += "No significant challenges encountered.\n"
        
        # Next Steps
        content += f"\n{SECTION_EMOJIS['next_steps']} NEXT STEPS\n"
        for step in data.get('next_steps', []):
            content += f"‚Ä¢ {step}\n"
        
        # Tags
        tags = data.get('tags', [])
        if tags:
            content += f"\n{SECTION_EMOJIS['tags']} Tags: {', '.join(tags)}\n"
        
        # Footer
        content += f"""
{"‚Äï" * 80}
Generated by Agentic AI Documentation Assistant

"""
        
        # Single insert request - this is the KEY to avoiding index issues
        requests = [
            {
                "insertText": {
                    "location": {"index": start_index},
                    "text": content
                }
            },
            {
                "insertPageBreak": {
                    "location": {"index": start_index + len(content)}
                }
            }
        ]
        
        return requests